---
layout: post
title: Palindromes
---

"So Many Dynamos!" is a palindrome. It's also the title of a [book](http://books.google.com/books?id=344CAAAACAAJ&amp;dq=so+many+dynamos) I bought through one of those Scholastic catalogs as a wee one. The palindromes, ranging from the seemingly profound ("Boston ode: Do Not Sob" illustrated by a bereft Red Sox fan) to the completely absurd ("Wee lunar granule! Ew..." made quasi-sensical by the image of an astronaut examining something and grimacing), fascinated me. Why? Perhaps because palindromes invert typical language construction: whereas normally we aim to convey _meaning_ with whichever words seem best fitted to do so, in writing palindromes we aim to constrain our words and will choose whichever meaning is most convenient.

It's not easy to write a palindrome, but perhaps it just became easier. As a project for [Hacker School](http://www.hackerschool.com), I built [palindromizer](http://www.galtman.com/palindromizer/) (Chrome browser only, for the moment)<del>, the first-ever (afaik)</del> UPDATE: ([Darius Bacon](http://wry.me), a Hacker Schooler himself, created [Palindromedary](http://wry.me/palindromedary/), more about that in my next post.), a text editor specifically for writing palindromes. Give it a try! For example, enter "Boston" followed by a space into the left box. Because "Mirror"-mode is on by default, you'll see "notsob" appear automagically in the right box. Go ahead and add a space (or any punctuation) between 'not' and 'sob' and you'll see it doesn't disturb the contents of the left box. Now you, Mr or Ms Palindrome-writer can see "Boston not sob" is a valid palindrome. But it doesn't make any sense. So throw in "Ode:" after "Boston". Now you'll have "Boston Ode: edonot sob". Add a space between "do" and "not" and you still have an extra "e". So you can go ahead and turn off Mirror-mode and erase that pesky "e". Voila! Palindrome.

If constructing palindromes is hard, building Palindromizer was perhaps a tad more difficult.

Enabling the program to either "mirror" user-input or not, and to go back and forth between those modes, was one hurdle. So I made a program to (1) take any piece of text, divided into left and right halves; (2) make an all-lower-case copy of the string excluding any punctuation of each half; (3) map the original (punctuated string) to the "scrubbed" string for later reconstitution for each half; (4) take successive smaller slices of one scrubbed half, flip those slices and search for those flipped pieces in the other half; and (5) upon finding a match, mark it as a "palindromic" piece. Then, recourse into any remaining pieces of text to find any smaller "sub"-palindromes. When all pieces of text have been evaluated to either have its "mirror" analog in the opposing piece or not, mark-up is added to display this information to the user.  Everything up to here is fairly de rigueur for javascript, but the catch came upon re-insertion: the browser would forget where the cursor should be. So, in addition to coding all the above, I also needed to make a side process keeping track of where the cursor is at all times, with the ability to put the cursor in the natural place the user will expect it to be after any new input.

Though I'm happy with the current status of the program, there are some more features I'd like to add to it. Most importantly, I want to implement an Auto-Complete in mirror-mode, so that while the user is writing words on one side, the program would try to parse the string of letters on the opposite side into words. In other words, when you entered "Boston" and "notsob" appeared, the program it self would tease the words "not" and "sob" out of the block of characters. That'd be nifty.